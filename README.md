# Prefix Tree Dict (OCaml)
Беля Алексей Иванович 408256

Лабораторная работа по функциональному программированию (ИТМО): 
реализация неизменяемого полиморфного словаря `string -> 'a` на основе префиксного дерева (trie).

## Задача

- Реализовать структуру данных "prefix tree dict":
  - интерфейс уровня обычного словаря (ассоциативного массива),
  - внутренняя структура данных — префиксное дерево (trie) по строковым ключам;
- Структура должна быть **неизменяемой** и **полиморфной** (`'a t`);
- Структура должна образовывать **моноид**:
  - нейтральный элемент `empty`,
  - ассоциативная операция объединения словарей `merge`;
- Реализовать базовые операции и функции высшего порядка:
  - `empty`, `is_empty`, `singleton`,
  - `insert`, `find_opt`, `mem`, `remove`,
  - `to_list`, `of_list`, `size`,
  - `map`, `mapi`, `filter`, `filter_values`,
  - `fold_left`, `fold_right`, `iter`;
- Реализовать операции над моноидом:
  - `merge`, `merge_with`, `concat`;
- Реализовать **эффективное сравнение** двух словарей `equal` без перевода в список и сортировки;
- Покрыть библиотеку **unit-тестами** и **property-based тестами** (QCheck), в том числе свойствами моноида.

## Структура проекта

- `dune-project` — описание dune-проекта и opam-пакета;
- `lib/`
  - `dune` — сборка библиотеки `prefix_tree_dict`;
  - `prefix_tree_dict.ml` — реализация структуры данных и всего публичного API;
- `test/`
  - `dune` — сборка тестового исполняемого файла;
  - `test_prefix_tree_dict.ml` — unit-тесты и property-based тесты.

## Основные идеи реализации

- Ключи — строки (`string`), обрабатываются как последовательность символов.
- Внутренняя структура узла:
  ```ocaml
  module CharMap = Map.Make(Char)
  
  type 'a t = {
    value : 'a option;              (* значение по ключу, заканчивающемуся в этом узле *)
    children : 'a t CharMap.t;      (* переходы по символам к поддеревьям *)
  }
  ```
- Операции `insert` / `find_opt` / `remove` рекурсивно спускаются по символам ключа.
- Функции высшего порядка (`map`, `mapi`, `filter`, `fold_left`, `fold_right`) реализованы как обход всего дерева с аккуратным восстановлением структуры.
- Моноидная операция `merge` объединяет два дерева, проходя синхронно по структуре и разрешая конфликты по значениям.
- `equal value_eq t1 t2` рекурсивно сравнивает структуру двух деревьев и значения с помощью переданной функции сравнения `value_eq`.

## Тестирование

Тесты написаны с использованием OUnit2 и QCheck.

Покрываются:
- базовые операции словаря (`insert`, `find_opt`, `mem`, `remove`, `to_list`, `of_list`, `size`);
- функции высшего порядка (`map`, `mapi`, `filter`, `fold_left`, `fold_right`);
- операции моноида (`merge`, `merge_with`, `concat`);
- сравнение `equal`, в том числе при разном порядке вставки ключей;
- дополнительные утилиты (`keys`, `values`, `find_prefix`, `has_prefix`, `iter`).

Property-based тесты (QCheck) проверяют, в частности:
- законы моноида: левый/правый нейтральный элемент `empty` и ассоциативность `merge`;
- корректность `insert`/`remove`/`find_opt`;
- согласованность `size` и `to_list`;
- законы для `map` (identity, композиция);
- свойства `filter` и `equal`.

## Как собрать и запустить тесты

Требуется установленный OCaml и dune (см. версии в `dune-project`).

В корне проекта (`lab2/`):

```bash
# Сборка проекта
 dune build

# Запуск всех тестов
 dune test
```

Результатом запуска тестов должен быть отчёт с успешным прохождением 
всех unit- и property-based тестов.

## Пример использования

Небольшой пример работы с модулем (см. также тесты):

```ocaml
open Prefix_tree_dict

let d =
  empty
  |> insert "cat" 1
  |> insert "car" 2
  |> insert "dog" 3

let () =
  match find_opt "car" d with
  | Some v -> Printf.printf "car = %d\n" v
  | None -> Printf.printf "car not found\n";

  let only_c = find_prefix "ca" d in
  List.iter (fun (k, v) -> Printf.printf "%s -> %d\n" k v) only_c
```

Этот код создаёт словарь, находит значение по ключу `"car"` и выводит все пары с префиксом `"ca"`.

## Отчёт по лабораторной

Подробное теоретическое объяснение (описание trie, моноида, property-based тестов 
и разбор ключевых функций `insert`, `remove`, `merge`, `filter`, `map`, `equal`) 
приведено в отдельном отчёте (`Беля_ФП_2.pdf`).
